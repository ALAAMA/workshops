# -*- eval: (save-excursion (org-babel-goto-named-src-block "workshopPreamble") (org-babel-execute-src-block)) -*-
#+TITLE:     Introduction To Programming In R
#+AUTHOR:    
#+EMAIL:     support@help.hmdc.harvard.edu
#+DATE:      ""
#+STARTUP: showeverything

# NOTE: refer to the README file if you are unfamiliar with emacs or orgmode.

# Customize the PROPERTY and EXCLUDE_TAGS below depending on the type
# of export (see the README file for details). After setting the exports 
# property and/or the EXCLUDE_TAGS, place the curser on the poperty line 
# and press C-c C-c

#+PROPERTY: exports both
#+EXCLUDE_TAGS: noexport mitsetup



#+SETUPFILE: ../workshopPreamble.org

#+name: setupR
#+begin_src R :exports none :tangle no :results silent
  rm(list=ls())
  .First <- function() {
    options(width=70)
    options(useFancyQuotes=FALSE)
    options(show.signif.stars=FALSE)
    require(rvest)
    require(readbitmap)
  }
#+end_src

#+name: workshopPreamble
#+begin_src emacs-lisp :exports none :results silent :tangle no
  (load-file "../setupEnvironment.el")
#+end_src


* Workshop overview and materials

** Workshop description
This is an intermediate/advanced R course appropriate for those with basic knowledge of R. It is intended for those already comfortable with using R for data analysis who wish to move on to writing their own functions. To the extent possible this workshop uses real-world examples. That is to say that concepts are introduced as they are needed for a realistic analysis task. 

 Prerequisite: basic familiarity with R, such as acquired from an introductory R workshop.

- Learning objectives:
  - Index data objects by position, name or logical condition
  - Understand looping and branching
  - Write your own simple functions
  - Debug functions
  - Understand and use the S3 object system

This workshop is free for Harvard and MIT affiliates. [[http://projects.iq.harvard.edu/rtc/workshop-registration][Click here to sign up!]]

- Instructor - [[http://projects.iq.harvard.edu/rtc/people/ista-zahn][Ista Zahn]]
- Location - Rm K018, 1737 Cambridge St (CGIS Knafel Building)

For further details and registration information, please contact us at [[mailto:dataclass@help.hmdc.harvard.edu][dataclass@help.hmdc.harvard.edu]]

** Materials and setup

Everyone should have R installed -- if not:

- Open a web browser and go to [[http://cran.r-project.org]] and download and install it
- Also helpful to install RStudio (download from [[http://rstudio.com]])

Materials for this workshop include slides, example data sets, and example code.

- Download materials from [[http://tutorials.iq.harvard.edu/R/RProgramming.zip]]
- Extract the zip file containing the materials to your desktop

** Launch RStudio on Athena					   :mitsetup:

- To start R *type these commands in the terminal*:
:     add r
:     rstudio
- Open up today's R script

  - In RStudio, Go to *File => Open Script*

  - Locate and open the =RProgramming.R= script in the Rintro folder in your home directory

- Go to *Tools => Set working directory => To source file location* (more on the working directory later)

- I encourage you to add your own notes to this file!

** Example project overview
Throughout this workshop we will return to a running example that involves acquiring, processing, and analyzing data from the [[http://www.census.gov/cps/][Current Population Survey]] (CPS). In this context we will learn about finding and using R packages, importing and manipulating data, writing functions, and more.

* I want all the data
It is common for data to be made available on a website somewhere, either by a government agency, research group, or other organizations and entities. Often the data you want is spread over many files, and retrieving it all one file at a time is tedious and time consuming. Such is the case with the CPS data we will be using today.

The Center for Economic and Policy Research has helpfully [[http://ceprdata.org/cps-uniform-data-extracts/cps-outgoing-rotation-group/cps-org-data/][compiled CPS data going back to 1979]][fn:1], one file per year. Although we could open a web browser and download these files one at a time, it will be faster and easier to instruct R to do that for us. Doing it this way will also give us an excuse to talk about regular expressions, package management, and other useful techniques.

Our goal is to download all the Stata data sets from http://ceprdata.org/cps-uniform-data-extracts/cps-outgoing-rotation-group/cps-org-data/. In order to do that we need a list of the Uniform Resource Locators (URLs) of those files. The URLs we need are right there as links in the ceprdata.org webpage. All we have to do is read that data in a way R can understand. 


** Searching text with regular expressions
Although some will say you should never ever attempt to extract information from html using regular expressions[fn:2], it does work OK for simple tasks. The fist step is to read the html into R. We can do that using the =readLines= function, like this:

#+BEGIN_SRC R :results silent
  ## Read html page from ceprdata.org into R. Each line will be stored as 
  ## an element in a vector of lines.
  ceprHtmlIndex <- readLines(
  "http://ceprdata.org/cps-uniform-data-extracts/cps-outgoing-rotation-group/cps-org-data/"
  )
#+END_SRC

OK, what are we working with?
#+BEGIN_SRC R
  ## how many lines do we have?
  length(ceprHtmlIndex)
  ## what do the first few lines look like?
  head(ceprHtmlIndex, 10) ## look at the first few lines of html

#+END_SRC

#+RESULTS:
#+begin_example
> ## how many lines do we have?
> length(ceprHtmlIndex)
[1] 295
> ## what do the first few lines look like?
> head(ceprHtmlIndex, 10) ## look at the first few lines of html
 [1] "<!doctype html>"                                                               
 [2] "<!--[if lt IE 7]> <html class=\"no-js ie6 oldie\" lang=\"en-US\"> <![endif]-->"
 [3] "<!--[if IE 7]>    <html class=\"no-js ie7 oldie\" lang=\"en-US\"> <![endif]-->"
 [4] "<!--[if IE 8]>    <html class=\"no-js ie8 oldie\" lang=\"en-US\"> <![endif]-->"
 [5] "<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en-US\"> <!--<![endif]-->" 
 [6] "<head>"                                                                        
 [7] "\t<meta charset=\"UTF-8\" />"                                                  
 [8] ""                                                                              
 [9] "\t<title>CPS ORG Data &#8211; ceprDATA</title>"                                
[10] ""                                                                              
> 
#+end_example

In html links are specified using the =<a>= (for /anchor/) tag. So now we want to search through our html and find lines that include an =a= tag. In R we can search for strings using the =grep= function.
#+BEGIN_SRC R
  ## find lines with links (a tags)
  (aLineNumbers <- grep("<a", ceprHtmlIndex)) # line numbers containing <a> tags
  head(aLines <- grep("<a", ceprHtmlIndex, value = TRUE)) # lines containing <a> tags
#+END_SRC

#+RESULTS:
#+begin_example
> ## find lines with links (a tags)
> (aLineNumbers <- grep("<a", ceprHtmlIndex)) # line numbers containing <a> tags
 [1] 141 143 149 150 151 152 153 154 155 156 167 169 173 175 176 177
[17] 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193
[33] 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209
[49] 210 212 219 223 225 226 227 228 231 233 234 235 236 239 241 242
[65] 243 244 247 249 250 251 252 255 257 258 259 260 263 264 265 267
[81] 269 271 273 282 285 289
> head(aLines <- grep("<a", ceprHtmlIndex, value = TRUE)) # lines containing <a> tags
[1] "\t\t\t\t\t\t\t\t\t<h1 id=\"site-name\"><a href=\"http://ceprdata.org/\" title=\"Home\" rel=\"home\"><img src=\"http://s403740266.onlinehome.us/wp-content/uploads/2012/03/ceprdata_logo.png\"></a></h1>"
[2] "\t\t\t\t<ul class=\"nav\"><li class=\"menu-item menu-item-type-taxonomy menu-item-object-category\"><a href=\"http://ceprdata.org/wp-login.php\">Log in</a></li></ul>\t\t\t\t</nav>"                    
[3] "\t\t\t\t<ul id=\"menu-top-menu\" class=\"nav\"><li id=\"menu-item-9\" class=\"menu-item menu-item-type-custom menu-item-object-custom menu-item-9\"><a href=\"http://www.ceprdata.org\">Home</a></li>"  
[4] "<li id=\"menu-item-8\" class=\"menu-item menu-item-type-post_type menu-item-object-page current-page-ancestor menu-item-8\"><a href=\"http://ceprdata.org/cps-uniform-data-extracts/\">CPS</a></li>"    
[5] "<li id=\"menu-item-13\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-13\"><a href=\"http://ceprdata.org/sipp-uniform-data-extracts/\">SIPP</a></li>"                      
[6] "<li id=\"menu-item-108\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-108\"><a href=\"http://ceprdata.org/acs-uniform-data-extracts/\">ACS</a></li>"                      
> 
#+end_example

So far we've successfully matched all lines containing the string "<a". Our actual target is a bit more specific. If we inspect the elements we want to match using our web browser we'll see something like this:[[file:images/inspectHtml.png]] 

#+BEGIN_SRC HTML :exports code
  <a onclick="_gaq.push(['_trackEvent', 'File','Download', 'cepr_org_2011']);" href="/wp-content/cps/data/cepr_org_2014.zip">cepr_org_2014.zip</a>
#+END_SRC
This tells us that we want to match lines containing an "<a" followed (eventually) by ".zip". In order to perform this more sophisticated search we need to use /regular expressions/. In regular expressions the =.= matches any character (except new lines) and the =*= repeats the previous character zero or more times. So =<a.*\\.zip= means "find =<a= followed by any character repeated any number of times followed by =.zip=". Note that in =\\.= the backslashes escape the dot so that it is matched literally rather than matching any character. Let's try it out!
#+BEGIN_SRC R
  ## find lines with <a> tags refering to zip files
  head(dataLines <- grep("<a.*\\.zip", ceprHtmlIndex, value = TRUE))
#+END_SRC

#+RESULTS:
#+begin_example
> ## find lines with <a> tags refering to zip files
> head(dataLines <- grep("<a.*\\.zip", ceprHtmlIndex, value = TRUE))
[1] "<li><a onclick=\"_gaq.push(['_trackEvent', 'File','Download', 'cepr_org_2011']);\" href=\"/wp-content/cps/data/cepr_org_2014.zip\">cepr_org_2014.zip</a></li>"
[2] "<li><a href=\"/wp-content/cps/data/cepr_org_2013.zip\">cepr_org_2013.zip</a></li>"                                                                            
[3] "<li><a href=\"/wp-content/cps/data/cepr_org_2012.zip\">cepr_org_2012.zip</a></li>"                                                                            
[4] "<li><a href=\"/wp-content/cps/data/cepr_org_2011.zip\">cepr_org_2011.zip</a></li>"                                                                            
[5] "<li><a onclick=\"_gaq.push(['_trackEvent', 'File','Download', 'cepr_org_2010']);\" href=\"/wp-content/cps/data/cepr_org_2010.zip\">cepr_org_2010.zip</a></li>"
[6] "<li><a onclick=\"_gaq.push(['_trackEvent', 'File','Download', 'cepr_org_2009']);\" href=\"/wp-content/cps/data/cepr_org_2009.zip\">cepr_org_2009.zip</a></li>"
> 
#+end_example

We're getting close! We have identified the lines containing the information we need. Now we just need to extract the text following the =href= argument. For that we need to use another feature of regular expressions called /capture groups/ and /back references/. Here's how it works:
#+BEGIN_SRC R
  head(dataURLs <- gsub("^.*href=\"(.*\\.zip)\".*$", "\\1", dataLines))
#+END_SRC

#+RESULTS:
#+begin_example
> head(dataURLs <- gsub("^.*href=\"(.*\\.zip)\".*$", "\\1", dataLines))
[1] "/wp-content/cps/data/cepr_org_2014.zip"
[2] "/wp-content/cps/data/cepr_org_2013.zip"
[3] "/wp-content/cps/data/cepr_org_2012.zip"
[4] "/wp-content/cps/data/cepr_org_2011.zip"
[5] "/wp-content/cps/data/cepr_org_2010.zip"
[6] "/wp-content/cps/data/cepr_org_2009.zip"
> 
#+end_example

Great, we've matched all the data file links. The next step is to iterate over these links and download the data. But before we get there, let's look at a couple of alternative methods we could use to get the list of data file links.

** Packages for parsing html
In the previous section we extracted data file links from an html page using regular expressions. An alternative is to use a package dedicated to parsing XML and HTML. How do we find such a package?
- Task views :: https://cran.r-project.org/web/views/WebTechnologies.html
- R package search :: http://www.r-pkg.org/search.html?q=html+xml
- Web search :: https://www.google.com/search?q=R+parse+html+xml&ie=utf-8&oe=utf-8

For parsing html in R I recommend either the =httr= package or the =rvest= package, with the former being more flexible and the later being more user friendly. Let's use the friendlier one.

#+BEGIN_SRC R
  ## install.packages("rvest")
  library(rvest)
  dataPage <- html("http://ceprdata.org/cps-uniform-data-extracts/cps-outgoing-rotation-group/cps-org-data/")

  ## find the link ("a") elemets extract the link ("href") attributes
  allLinks <- html_attr(html_nodes(dataPage, "a"), "href")
  dataLinks <- paste("http://ceprdata.org",
                     grep("^/wp-content/cps/data/.*\\.zip$",
                          allLinks,
                          value = TRUE),
                     sep = "")
head(dataLinks)
#+END_SRC

#+RESULTS:
#+begin_example
>   ## install.packages("rvest")
>   library(rvest)
>   dataPage <- html("http://ceprdata.org/cps-uniform-data-extracts/cps-outgoing-rotation-group/cps-org-data/")
> 
>   ## find the link ("a") elemets extract the link ("href") attributes
>   allLinks <- html_attr(html_nodes(dataPage, "a"), "href")
>   dataLinks <- paste("http://ceprdata.org",
+                      grep("^/wp-content/cps/data/.*\\.zip$",
+                           allLinks,
+                           value = TRUE),
+                      sep = "")
> head(dataLinks)
[1] "http://ceprdata.org/wp-content/cps/data/cepr_org_2014.zip"
[2] "http://ceprdata.org/wp-content/cps/data/cepr_org_2013.zip"
[3] "http://ceprdata.org/wp-content/cps/data/cepr_org_2012.zip"
[4] "http://ceprdata.org/wp-content/cps/data/cepr_org_2011.zip"
[5] "http://ceprdata.org/wp-content/cps/data/cepr_org_2010.zip"
[6] "http://ceprdata.org/wp-content/cps/data/cepr_org_2009.zip"
> 
#+end_example

Wow, that that was a lot easier. Why didn't we do that in the first place?!? Well, if we had done it the easy way I wouldn't have had an excuse to teach you about regular expressions! And trust me, you need to know about regular expressions. 

** Getting the list of data links the easy way
If you look at the result from the previous two methods you might notice that the URLs are all the same save for the year number. This suggests an even easier way to construct the list of URLs:
#+BEGIN_SRC R
  head(dataLinks <- paste("http://ceprdata.org/wp-content/cps/data/cepr_org_",
                      1979:2014,
                      ".zip",
                      sep = ""))

#+END_SRC

#+RESULTS:
#+begin_example
> head(dataLinks <- paste("http://ceprdata.org/wp-content/cps/data/cepr_org_",
+                     1979:2014,
+                     ".zip",
+                     sep = ""))
[1] "http://ceprdata.org/wp-content/cps/data/cepr_org_1979.zip"
[2] "http://ceprdata.org/wp-content/cps/data/cepr_org_1980.zip"
[3] "http://ceprdata.org/wp-content/cps/data/cepr_org_1981.zip"
[4] "http://ceprdata.org/wp-content/cps/data/cepr_org_1982.zip"
[5] "http://ceprdata.org/wp-content/cps/data/cepr_org_1983.zip"
[6] "http://ceprdata.org/wp-content/cps/data/cepr_org_1984.zip"
> 
#+end_example

Wow, that was a _lot_ easier. Why oh why didn't we just do that in the first place? Well, it works for this specific case, but it is much less general than the regular expression method or the html parsing method we discussed previously. Those methods will work in the general case, while pasting the year number into the URLs only works because the URLs we want have a very regular and consistent form.

* Iteration and functions
Now that we have a vector of URLs pointing to the data files we want to download, we want to iterate over the elements and download each file. We could do this verbosely by writing one line for each file:
#+BEGIN_SRC R :results silent
  dir.create("dataSets")
  download.file(dataLinks[1], "dataSets/cepr_org_1979.zip")
  download.file(dataLinks[2], "dataSets/cepr_org_1980.zip")
  ## ...
  ## download.file(dataLinks[n], "dataSets/cepr_org_n.zip")
#+END_SRC
but that is too much typing. Much easier to let R do that for us. We can iterate over the elements of a vector in R using a loop, or using one of the =apply= family of functions.

=for= and =while= loops in R work much the same as they do in other programming languages. The =apply= family of functions apply a function to each element of an object.

** Iterating using for-loop
One way to download the data files is to use a for-loop to iterate over the contents of our vector of URLs. Some people will tell you to avoid for-loops in R but this is nonsense. Loops are convenient and useful, and while they are not the best tool for all situations calling for iteration they are perfectly appropriate for downloading a series of files. If you've used a for loop in any other language you will probably find the R implementation to be very similar. 

For now, lets start by downloading just the data files for years since 2010.

#+BEGIN_SRC R :results silent
  for(link in grep("org_201", dataLinks, value = TRUE)) {
      download.file(link, 
                    destfile = basename(link))
  }
#+END_SRC

** Writing functions
Our for loop works well for downloading the data files form ceprdata.org. But what if we need to download data from other URLs as well? It might be nice to have a re-usable function that takes a url and downloads it, saving the result as the =basename= of the url. We can define such a function using the =function= function (say that three times fast!).
#+BEGIN_SRC R :results silent
  downloadFiles <- function(urls) {
    for(link in urls) {
        download.file(link, 
                      destfile = basename(link))
    }
  }
#+END_SRC

Now we can download files more simply with
#+BEGIN_SRC R :results silent
  downloadFiles(grep("org_201", dataLinks, value = TRUE))
#+END_SRC
and in fact we can use this function to download files from any urls we might have. As a silly example, let's download all the profile pictures from the [[http://projects.iq.harvard.edu/rtc][Research Technology Consulting]] team at [[http://iq.harvard.edu][The Institute for Quantitative Social Science]]: 
#+BEGIN_SRC R 
  library(readbitmap)
  ## parse the webpage and extract image URLs
  profilePicLinks <- html_attr(html_nodes(html("http://projects.iq.harvard.edu/rtc/people"),
                                          ".image-style-profile-thumbnail"),
                               "src")
  ## clean up the links
  profilePicLinks <- gsub("\\.png\\?.*$", ".png", profilePicLinks)
  ## download
  downloadFiles(paste("http:", profilePicLinks, sep=""))
  ## list downloaded image files
  list.files(pattern = "\\.png$")
#+END_SRC

#+RESULTS:
#+begin_example
> library(readbitmap)
> ## parse the webpage and extract image URLs
> profilePicLinks <- html_attr(html_nodes(html("http://projects.iq.harvard.edu/rtc/people"),
+                                         ".image-style-profile-thumbnail"),
+                              "src")
> ## clean up the links
> profilePicLinks <- gsub("\\.png\\?.*$", ".png", profilePicLinks)
> ## download
> downloadFiles(paste("http:", profilePicLinks, sep=""))
> ## list downloaded image files
> list.files(pattern = "\\.png$")
[1] "default-profile.png"      "ista_zahn-5.png"         
[3] "simo_goshev.png"          "steven_worthington-2.png"
> 
#+end_example

The code above downloaded all the profile pics from http://projects.iq.harvard.edu/rtc/people. Although this doesn't have anything to do with our main goal of downloading and analyzing the data from ceprdata.org, we'll go ahead and plot these images, just for fun.
#+BEGIN_SRC R :results output graphics :file images/rtc_people.png
  ## install.packages("readbitmap")
  library(readbitmap); library(grid); library(gridExtra)

  imgs <- sapply(list.files(pattern = "\\.png$"),
                 read.bitmap,
                 simplify = FALSE)
  do.call(grid.arrange, sapply(imgs, rasterGrob, simplify = FALSE))
#+END_SRC

#+RESULTS:
[[file:images/rtc_people.png]]

** The applying functions
You might have noticed that I slipped an example of =sapply= into the previous example. =sapply= is one of the apply family of functions in R that are useful for iteration. The apply family of functions includes:
- apply :: apply a function to each dimension (e.g., row or column), of a matrix or array
- lapply :: apply a function to each element of a vector or list
- sapply :: like lapply, but simplifies the result
- mapply :: apply a function to each element of multiple vectors or lists

Confused yet? The bad news is, there are more of these; see =?lapply=, =?Map= and [[http://stackoverflow.com/questions/3505701/r-grouping-functions-sapply-vs-lapply-vs-apply-vs-tapply-vs-by-vs-aggrega][this StackOverflow answer]] for details. The good news is you can do quite a lot with just =apply= and =sapply=. 

*** Iterating over vectors and lists with the =sapply= function
The =sapply= function iterates over a vector or list and applys a function to each element. To start, let's use =sapply= do download all the data files for years since 2010:
#+BEGIN_SRC R :results silent
  sapply(grep("org_201", dataLinks, value = TRUE),
         function(x) download.file(x, destfile = basename(x))
         )
#+END_SRC

#+RESULTS:
#+begin_example
> sapply(grep("org_201", dataLinks, value = TRUE),
+        function(x) download.file(x, destfile = basename(x))
+        )
http://ceprdata.org/wp-content/cps/data/cepr_org_2010.zip 
                                                        0 
http://ceprdata.org/wp-content/cps/data/cepr_org_2011.zip 
                                                        0 
http://ceprdata.org/wp-content/cps/data/cepr_org_2012.zip 
                                                        0 
http://ceprdata.org/wp-content/cps/data/cepr_org_2013.zip 
                                                        0 
http://ceprdata.org/wp-content/cps/data/cepr_org_2014.zip 
                                                        0 
> 
#+end_example

For this task (downloading files) there is not much advantage to using =sapply= instead of =for=. The main advantage is the simpler handling of return values. To see this, let's revisit the profile picture example. Our goal is to read all the .png files in our working directory. We've already seen how to do this with =sapply=;
#+BEGIN_SRC R :results silent
  imgs <- sapply(list.files(pattern = "\\.png$"),
                 read.bitmap)
#+END_SRC
How can we do that with a for loop? First we need to create a list to store the restults, then as we loop through we need to assign the image data to an element of the list. It's not terrible:
#+BEGIN_SRC R :results silent
  imgs <- list()
  for (file in list.files(pattern = "\\.png$")) {
    imgs[[file]] <- read.bitmap(file)
  }
#+END_SRC
As I said, not terrible, but definitely more complicated than the sapply version. 

**** Iterating over arrays with the =apply= function
Now that we've downloaded some of the ceprdata.org data we might want to get some information about these files. We can do that using the =file.info= function:
#+BEGIN_SRC R
  ceprFiles <- list.files(pattern = "\\.zip")
  ceprFileInfo <- cbind(size = file.size(ceprFiles), mode = file.mode(ceprFiles))
  rownames(ceprFileInfo) <- ceprFiles
  ceprFileInfo
#+END_SRC

#+RESULTS:
#+begin_example
> ceprFiles <- list.files(pattern = "\\.zip")
> ceprFileInfo <- cbind(size = file.size(ceprFiles), mode = file.mode(ceprFiles))
> rownames(ceprFileInfo) <- ceprFiles
> ceprFileInfo
                      size mode
cepr_org_2010.zip 14969769  420
cepr_org_2011.zip 14811229  420
cepr_org_2012.zip 14774713  420
cepr_org_2013.zip 14627250  420
cepr_org_2014.zip 14477818  420
> 
#+end_example
ceprFileInfo is a _matrix_, with each row containing information about one of the files we downloaded. We can calculate the means for each column in this mattrix using the =apply= fuction:

#+begin_src R
  ## average file size and permissions
  (fileInfoAverage <- apply(ceprFileInfo, MARGIN = 2, mean))
  ## standard deviation of file size and permissions
  apply(ceprFileInfo, MARGIN = 2, sd)
  ## deviation from the average
  apply(ceprFileInfo, MARGIN = 1, function(x) x - fileInfoAverage) # 

#+end_src

#+RESULTS:
#+begin_example
> ## average file size and permissions
> (fileInfoAverage <- apply(ceprFileInfo, MARGIN = 2, mean))
    size     mode 
14732156      420 
> ## standard deviation of file size and permissions
> apply(ceprFileInfo, MARGIN = 2, sd)
    size     mode 
187227.6      0.0 
> ## deviation from the average
> apply(ceprFileInfo, MARGIN = 1, function(x) x - fileInfoAverage) # 
     cepr_org_2010.zip cepr_org_2011.zip cepr_org_2012.zip
size          237613.2           79073.2           42557.2
mode               0.0               0.0               0.0
     cepr_org_2013.zip cepr_org_2014.zip
size         -104905.8         -254337.8
mode               0.0               0.0
> 
#+end_example
#+RESULTS: sapplyExample
#+begin_example
> sapply(DF, class) # get the class of each column in the DF data.frame
        x         y 
"integer"  "factor" 
> sapply(L, length) # get the length of each element in the L list
x y z 
5 3 2 
> sapply(DF, is.numeric) # check each column of DF to see if it is numeric
    x     y 
 TRUE FALSE 
> 
#+end_example

See also: =lapply=, =vapply=, and =mapply=.
** Combining sapply and indexing
The =sapply= function can be used in combination with indexing to extract elements that meet certain criteria
- Recall that we can index using logical vectors:
#+name: sapplyAndIndexing1
#+begin_src R
  DF[, c(TRUE, FALSE)] # select the first column of DF, but not the second
#+end_src

#+RESULTS: sapplyAndIndexing1
#+begin_example
> DF[, c(TRUE, FALSE)] # select the first column of DF, but not the second
[1] 1 2 3 4 5
> 
#+end_example

#+RESULTS: sapplyAndIndexing
#+begin_example
> ## recall that we can index using logical vectors:
> DF[, c(TRUE, FALSE)] # select the first column of DF, but not the second
[1] 1 2 3 4 5
> 
#+end_example

- =sapply()= can be used to generate the logical vector
#+name: sapplyAndIndexing2
#+begin_src R
  (DF.which.num <- sapply(DF, is.numeric))# check which columns of DF are numeric
  DF[DF.which.num] # select the numeric columns
#+end_src

#+RESULTS: sapplyAndIndexing2
#+begin_example
> (DF.which.num <- sapply(DF, is.numeric))# check which columns of DF are numeric
    x     y 
 TRUE FALSE 
> DF[DF.which.num] # select the numeric columns
  x
1 1
2 2
3 3
4 4
5 5
> 
#+end_example

Note the difference between =DF[, 1]= and =DF[1]=! The first form returns a vector, the second a data.frame with one column. 

** Applying functions summary
Key points:
- R has convenient methods for applying functions to matricies, lists, and data.frames
- other apply-style functions exist, e.g., lapply, tapply, and mapply (see documentation of these functions for details
Functions introduced in this section: 
- matrix :: create a matrix (vector with two dimensions)
- apply :: apply a function to the rows or columns of a matrix
- sapply :: apply a function to the elements of a list
- is.numeric :: returns TRUE or FALSE, depending on the type of object 

* Extracting and replacing object elements

** Indexing by position or name
Parts of vectors, matricies, data.frames, and lists can be extracted or replaced based on position or name
#+name: indexingVectors
#+begin_src R 
  ## indexing vectors by position
  x <- 101:110 # Creat a vector of integers from 101 to 110
  x[c(4, 5)] # extract the fourth and fifth values of x
  x[4] <- 1 # change the 4th value to 1
  x # print x
  
  ## indexing vectors by name
  names(x) <- letters[1:10] # give x names
  print(x) #print x
  x[c("a", "f")] # extract the values of a  and f from x
#+end_src

#+RESULTS: indexingVectors
#+begin_example
> ## indexing vectors by position
> x <- 101:110 # Creat a vector of integers from 101 to 110
> x[c(4, 5)] # extract the fourth and fifth values of x
[1] 104 105
> x[4] <- 1 # change the 4th value to 1
> x # print x
 [1] 101 102 103   1 105 106 107 108 109 110
> 
> ## indexing vectors by name
> names(x) <- letters[1:10] # give x names
> print(x) #print x
  a   b   c   d   e   f   g   h   i   j 
101 102 103   1 105 106 107 108 109 110 
> x[c("a", "f")] # extract the values of a  and f from x
  a   f 
101 106 
> 
#+end_example

** Logical indexing
Elements can also be selected or replaced based on logical (TRUE/FALSE) vectors.

#+name: logicalIndexingVectors
#+begin_src R
  x > 106 # shows which elements of x are > 106
  x[x > 106] # selects elements of x where x > 106 
#+end_src

#+RESULTS: logicalIndexingVectors
#+begin_example
> x > 106 # shows which elements of x are > 106
    a     b     c     d     e     f     g     h     i     j 
FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE 
> x[x > 106] # selects elements of x where x > 106 
  g   h   i   j 
107 108 109 110 
> 
#+end_example

Additional operators useful for logical indexing:
- == :: equal to 
- != :: not equal to
- > :: greater than
- < :: less than
- >= :: greater than or equal to
- <= :: less than or equal to
- %in% :: is included in
- & :: and
- | :: or

#+name: logicalIndexingVectors2
#+begin_src R
  x[x > 106 & x <= 108]
  x[x > 106 | names(x) %in% c("a", "b", "c")]
#+end_src

#+RESULTS: logicalIndexingVectors2
#+begin_example
> x[x > 106 & x <= 108]
  g   h 
107 108 
> x[x > 106 | names(x) %in% c("a", "b", "c")]
  a   b   c   g   h   i   j 
101 102 103 107 108 109 110 
> 
#+end_example


** Indexing matrices
Extraction on matrices operate in two dimensions: first dimension refers to rows, second dimension refers to columns

#+name: indexingMatricies
#+begin_src R 
  ## indexing matricies
   # create a matrix
  (M <- cbind(x = 1:5, y = -1:-5, z = c(6, 3, 4, 2, 8)))
  M[1:3, ] #extract rows 1 through 3, all columns
  M[c(5, 3, 1), 2:3] # rows 5, 3 and 1, columns 2 and 3
  M[M[, 1] %in% 4:2, 2] # second column where first column <=4 & >= 2
#+end_src

#+results: indexingMatricies
#+begin_example
> ## indexing matricies
>  # create a matrix
> (M <- cbind(x = 1:5, y = -1:-5, z = c(6, 3, 4, 2, 8)))
     x  y z
[1,] 1 -1 6
[2,] 2 -2 3
[3,] 3 -3 4
[4,] 4 -4 2
[5,] 5 -5 8
> M[1:3, ] #extract rows 1 through 3, all columns
     x  y z
[1,] 1 -1 6
[2,] 2 -2 3
[3,] 3 -3 4
> M[c(5, 3, 1), 2:3] # rows 5, 3 and 1, columns 2 and 3
      y z
[1,] -5 8
[2,] -3 4
[3,] -1 6
> M[M[, 1] %in% 4:2, 2] # second column where first column <=4 & >= 2
[1] -2 -3 -4
> 
#+end_example

Note that unspecified index's (as in the column index in the example above ) return all values.


** Indexing lists
Lists can be indexed in the same way as vectors, with the following extension:
#+name: ListIndexing
#+begin_src R
  # Lists can be indexed with single brackets, similar to vector indexing
  L[c(1, 2)] # the first two elements of L
  L[1] # a list with one element
  ## double brackets select the content of a single selected element
  ## effectively taking it out of the list.
  L[[1]] # a vector
#+end_src

#+RESULTS: ListIndexing
#+begin_example
> # Lists can be indexed with single brackets, similar to vector indexing
> L[c(1, 2)] # the first two elements of L
$x
[1] 1 2 3 4 5

$y
[1] 1 2 3

> L[1] # a list with one element
$x
[1] 1 2 3 4 5

> ## double brackets select the content of a single selected element
> ## effectively taking it out of the list.
> L[[1]] # a vector
[1] 1 2 3 4 5
> 
#+end_example

** Indexing data.frames

A data.frame can be indexed in the same ways as a matrix, and also the same ways as a list:

#+name: DataFrameIndexing
#+begin_src R
  DF[c(3, 1, 2), c(1, 2)] # rows 3, 1, and 2, columns 1 and 2
  DF[[1]] # column 1 as a vector
#+end_src

#+RESULTS: DataFrameIndexing
#+begin_example
> DF[c(3, 1, 2), c(1, 2)] # rows 3, 1, and 2, columns 1 and 2
  x y
3 3 c
1 1 a
2 2 b
> DF[[1]] # column 1 as a vector
[1] 1 2 3 4 5
> 
#+end_example

There is a subtle but important difference between =[ , n]= and =[n]= when indexing data.frames: the first form returns a vector, the second returns a data.frame with one column.
#+name: dataFrameIndexingComplicated
#+begin_src R
  str(DF[1])# a data.frame with one column
  str(DF[ ,1])# a vector
#+end_src

#+RESULTS: dataFrameIndexingComplicated
#+begin_example
> str(DF[1])# a data.frame with one column
'data.frame':	5 obs. of  1 variable:
 $ x: int  1 2 3 4 5
> str(DF[ ,1])# a vector
 int [1:5] 1 2 3 4 5
> 
#+end_example

** Extraction/replacement summary
Key points:

- elements of objects can be extracted or replaced using the =[= operator
- objects can be indexed by position, name, or logical (TRUE/FALSE) vectors
- vectors and lists have only one dimension, and hence only one index is used 
- matricies and data.frames have two dimensions, and extraction methods for these objects use two indices 
Functions introduced in this section: 
- [ :: extraction operator, used to extract/replace object elements
- names :: get the names of an object, usually a vector, list, or data.frame
- print :: print an object 


** Exercise 1

1) Select just the Sepal.Length and Species columns from the /iris/ data set (built-in, will be available in your workspace automatically) and save the result to a new data.frame named /iris.2/
2) Calculate the mean of the Sepal.Length column in /iris.2/ 
3) BONUS (optional): Calculate the mean of Sepal.Length, but only for the setosa species
4) BONUS (optional): Calculate the number of sepal lengths that are more than one standard deviation below the average sepal length

* Control flow

** Control flow 
- Basic idea: if some condition is true, do one thing. If false, do something else
- Carried out in R using ~if()~ and ~else()~ statements, which can be nested if necessary
- Especially useful for checking function arguments and performing different operations depending on function input

** Control flow examples
Goal: write a function that tells us if a number is positive or negative

#+name: brachingExample1
#+begin_src R
  ## use branching to return different result depending on the sign of the input
  isPositive <- function(x) { # define function "isPositive"
    if (x > 0) { # if x is greater than zero, then
      return(paste(x, "is positive \n")) } # say so! 
    else { # otherwise
        return(paste(x, "is negative \n"))} # say x is negative
  } # end function definition 

  ## test the isPositive() function
  isPositive(10)
  isPositive(-1)
  isPositive(0)
#+end_src

#+RESULTS: brachingExample1
#+begin_example
> ## use branching to return different result depending on the sign of the input
> isPositive <- function(x) { # define function "isPositive"
+   if (x > 0) { # if x is greater than zero, then
+     return(paste(x, "is positive \n")) } # say so! 
+   else { # otherwise
+       return(paste(x, "is negative \n"))} # say x is negative
+ } # end function definition 
> 
> ## test the isPositive() function
> isPositive(10)
[1] "10 is positive \n"
> isPositive(-1)
[1] "-1 is negative \n"
> isPositive(0)
[1] "0 is negative \n"
> 
#+end_example

Need to do something different if x equals zero!

** Control flow examples

Add a condition to handle =x = 0=

#+name: brachingExample3
#+begin_src R
  ## add condition to handle the case that x is zero
    isPositive <- function(x) { # define function "isPositive"
      if (x > 0) { # if x is greater than zero, then
        return(paste(x, "is positive \n")) } # say so! 
      else if (x == 0) { # otherwise if x is zero
        return(paste(x, "is zero \n"))} # say so!
      else { #otherwise
          return(paste(x, "is negative \n"))} # say x is negative
    } # end function definition
#+end_src

#+RESULTS: brachingExample3
#+begin_example
> ## add condition to handle the case that x is zero
>   isPositive <- function(x) { # define function "isPositive"
+     if (x > 0) { # if x is greater than zero, then
+       return(paste(x, "is positive \n")) } # say so! 
+     else if (x == 0) { # otherwise if x is zero
+       return(paste(x, "is zero \n"))} # say so!
+     else { #otherwise
+         return(paste(x, "is negative \n"))} # say x is negative
+   } # end function definition
> 
#+end_example

Test the new function

#+name: brachingExample3.1
#+begin_src R
  isPositive(0) # test the isPositive() function
  isPositive("a") #oops, that will not work!
#+end_src

#+RESULTS: brachingExample3.1
#+begin_example
> isPositive(0) # test the isPositive() function
[1] "0 is zero \n"
> isPositive("a") #oops, that will not work!
[1] "a is positive \n"
> 
#+end_example

We fixed the problem when =x = 0=, but now we need to make sure x is numeric of length one (unless we agree with R that =a= is positive!)

** Control flow examples

Do something reasonable if x is not numeric

#+name: brachingExample5
#+begin_src R :eval no
  ## add condition to handle the case that x is zero
    isPositive <- function(x) { # define function "isPositive"
      if(!is.numeric(x) | length(x) > 1) {
        stop("x must be a numeric vector of length one! \n")}
      else if (x > 0) { # if x is greater than zero, then
        return(paste(x," is positive \n")) } # say so! 
      else if (x == 0) { # otherwise if x is zero
        return(paste(x," is zero \n"))} # say so!
      else { #otherwise
        return(paste(x," is negative \n"))} # say x is negative
    } # end function definition

  isPositive("a") # test the isPositive() function on character
#+end_src

#+RESULTS: brachingExample5
#+begin_example
> isPositive("a")
Error in isPositive("a") : x must be a numeric vector of length one! 
#+end_example


** Control flow summary 
Key points:
- code can be conditionally executed
- conditions can be nested 
- conditional execution is often used for argument checking, among other things

Functions introduced in this section  
- paste :: concatenates (character) vectors
- if :: execute code only if condition is met
- else :: used with *if*; code to execute if condition is not met


** Exercise 3

1) Add argument checking code to return an error if the argument to your function is not a data.frame

2) Insert a break point with =browser()= and step through your function

* The S3 object class system

** The S3 object class system 
R has two major object systems: 
  - Relatively informal "S3" classes 
  - Stricter, more formal "S4" classes 
- We will cover only the S3 system, not the S4 system
- Basic idea: functions have different methods for different types of objects

** Object class
The class of an object can be retrieved and modified using the ~class()~ function:

#+name: classExample
#+begin_src R
  x <- 1:10
  class(x) 
  class(x) <- "foo"
  class(x)
#+end_src

#+results: classExample
#+begin_example
> x <- 1:10
> class(x) 
[1] "integer"
> class(x) <- "foo"
> class(x)
[1] "foo"
> 
#+end_example

 Objects are not limited to a single class, and can have many classes:

#+name: classExample2
#+begin_src R
  class(x) <- c("A", "B")
  class(x) 
#+end_src

#+results: classExample2
#+begin_example
> class(x) <- c("A", "B")
> class(x) 
[1] "A" "B"
> 
#+end_example


** Function methods
- Functions can have many methods, allowing us to have (e.g.) one plot() function that does different things depending on what is being plotted()
- Methods can only be defined for generic functions: plot, print, summary, mean, and several others are already generic

#+name: getMethods
#+begin_src R 
  # see what methods have been defined for the mean function
  methods(mean)
  # which functions have methods for data.frames?
  methods(class="data.frame")[1:9]
#+end_src

#+results: getMethods
#+begin_example
> # see what methods have been defined for the mean function
> methods(mean)
[1] mean.Date     mean.default  mean.difftime mean.POSIXct 
[5] mean.POSIXlt 
> # which functions have methods for data.frames?
> methods(class="data.frame")[1:9]
[1] "[.data.frame"             "[[.data.frame"           
[3] "[[<-.data.frame"          "[<-.data.frame"          
[5] "$<-.data.frame"           "aggregate.data.frame"    
[7] "anyDuplicated.data.frame" "as.data.frame.data.frame"
[9] "as.list.data.frame"      
> 
#+end_example


** Creating new function methods
To create a new method for a function that is already generic all you have to do is name your function ~function.class~

#+name: fooMean
#+begin_src R 
  # create a mean() method for objects of class "foo":
  mean.foo <- function(x) { # mean method for "foo" class
    if(is.numeric(x)) {
      cat("The average is", mean.default(x))
      return(invisible(mean.default(x))) #use mean.default for numeric
    } else
      cat("x is not numeric \n")} # otherwise say x not numeric
  
  x <- 1:10
  mean(x)
  class(x) <- "foo"
  mean(x)
 
  x <- as.character(x)
  class(x) <- "foo"
  mean(x)
#+end_src

#+RESULTS: fooMean
#+begin_example
> # create a mean() method for objects of class "foo":
> mean.foo <- function(x) { # mean method for "foo" class
+   if(is.numeric(x)) {
+     cat("The average is", mean.default(x))
+     return(invisible(mean.default(x))) #use mean.default for numeric
+   } else
+     cat("x is not numeric \n")} # otherwise say x not numeric
> 
> x <- 1:10
> mean(x)
[1] 5.5
> class(x) <- "foo"
> mean(x)
The average is 5.5>  
> x <- as.character(x)
> class(x) <- "foo"
> mean(x)
x is not numeric 
> 
#+end_example


** Creating generic functions

S3 generics are most often used for print, summary, and plot methods, but sometimes you may want to create a new generic function

#+name: createGeneric
#+begin_src R
  # create a generic disp() function
  disp <- function(x, ...) {
    UseMethod("disp")
  }
  
  # create a disp method for class "matrix"
  disp.matrix <- function(x) {
    print(round(x, digits=2))
  }
  
  # test it out
  disp(matrix(runif(10), ncol=2))  
#+end_src

#+RESULTS: createGeneric
#+begin_example
> # create a generic disp() function
> disp <- function(x, ...) {
+   UseMethod("disp")
+ }
> 
> # create a disp method for class "matrix"
> disp.matrix <- function(x) {
+   print(round(x, digits=2))
+ }
> 
> # test it out
> disp(matrix(runif(10), ncol=2))  
     [,1] [,2]
[1,] 0.45 0.79
[2,] 0.96 0.36
[3,] 0.14 0.06
[4,] 0.78 0.57
[5,] 0.80 0.66
> 
#+end_example


** S3 classes summary 
Key points:
- there are several class systems in R, of which S3 is the oldest and simplest
- objects have /class/ and functions have corresponding /methods/
- the class of an object can be set by simple assignment
- S3 generic functions all contain ~UseMethod("x")~ in the body, where ~x~ is the name of the function
- new methods for existing generic functions can be written simply by defining a new function with a special naming scheme: the name of the function followed by dot followed by the name of the class

Functions introduced in this section  
- plot :: creates a graphical display, the type of which depends on the class of the object being plotted
- methods :: lists the methods defined for a function or class
- UseMethod :: the body of a generic function
- invisible :: returns an object but does not print it



** Exercise 4 
1) Modify your function so that it also returns the standard deviations of the numeric variables 

2) Modify your function so that it returns a list of class "statsum"

3) Write a print method for the statsum class

* Things that may surprise you

** Gotcha's

- There are an unfortunately large number of surprises in R programming
- Some of these "gotcha's" are common problems in other languages, many are unique to R
- We will only cover a few -- for a more comprehensive discussion please see http://www.burns-stat.com/pages/Tutor/R_inferno.pdf


** Floating point comparison

Floating point arithmetic is not exact:
#+name: floatingPointExample
#+begin_src R
  .1 == .3/3
#+end_src

#+RESULTS: floatingPointExample
#+begin_example
> .1 == .3/3
[1] FALSE
> 
#+end_example

Solution: ~use all.equal()~:
#+name: floatingPointExampleSolution
#+begin_src R
  all.equal(.1, .3/3)
#+end_src

#+RESULTS: floatingPointExampleSolution
#+begin_example
> all.equal(.1, .3/3)
[1] TRUE
> 
#+end_example

** Missing values
R does not exclude missing values by default -- a single missing value in a vector means that many thing are unknown:
#+name: MissingDataExample
#+begin_src R
  x <- c(1:10, NA, 12:20)
  c(mean(x), sd(x), median(x), min(x), sd(x))
#+end_src

#+RESULTS: MissingDataExample
#+begin_example
> x <- c(1:10, NA, 12:20)
> c(mean(x), sd(x), median(x), min(x), sd(x))
[1] NA NA NA NA NA
> 
#+end_example

NA is not equal to anything, not even NA
#+name: NAcomp
#+begin_src R
  NA == NA
#+end_src

#+RESULTS: NAcomp
#+begin_example
> NA == NA
[1] NA
> 
#+end_example

Solutions: use ~na.rm = TRUE~ option when calculating, and is.na to test for missing

** Automatic type conversion

Automatic type conversion happens a lot which is often useful, but makes it easy to miss mistakes

#+name: typeConversion
#+begin_src R
  # combining values coereces them to the most general type
  (x <- c(TRUE, FALSE, 1, 2, "a", "b"))
  str(x)
  
  # comparisons convert arguments to most general type
  1 > "a"
#+end_src

#+RESULTS: typeConversion
#+begin_example
> # combining values coereces them to the most general type
> (x <- c(TRUE, FALSE, 1, 2, "a", "b"))
[1] "TRUE"  "FALSE" "1"     "2"     "a"     "b"    
> str(x)
 chr [1:6] "TRUE" "FALSE" "1" "2" "a" "b"
> 
> # comparisons convert arguments to most general type
> 1 > "a"
[1] FALSE
> 
#+end_example

Maybe this is what you expect... I would like to at least get a warning!

** Optional argument inconsistencies
Functions you might expect to work similarly don't always:

#+name: MeanVSsd
#+begin_src R
  mean(1, 2, 3, 4, 5)*5
  sum(1, 2, 3, 4, 5)
#+end_src

#+RESULTS: MeanVSsd
#+begin_example
> mean(1, 2, 3, 4, 5)*5
[1] 5
> sum(1, 2, 3, 4, 5)
[1] 15
> 
#+end_example

Why are these different?!?
#+name: MeanVSsdExplained
#+begin_src R
  args(mean)
  args(sum)
#+end_src

#+RESULTS: MeanVSsdExplained
#+begin_example
> args(mean)
function (x, ...) 
NULL
> args(sum)
function (..., na.rm = FALSE) 
NULL
> 
#+end_example

Ouch. That is not nice at all!

** Trouble with Factors

Factors sometimes behave as numbers, and sometimes as characters, which can be confusing!

#+name: factorTrouble
#+begin_src R
  (x <- factor(c(5, 5, 6, 6), levels = c(6, 5)))
  
  str(x)
  
  as.character(x)
  # here is where people sometimes get lost...
  as.numeric(x)
  # you probably want
  as.numeric(as.character(x))
#+end_src

#+RESULTS: factorTrouble
#+begin_example
> (x <- factor(c(5, 5, 6, 6), levels = c(6, 5)))
[1] 5 5 6 6
Levels: 6 5
> 
> str(x)
 Factor w/ 2 levels "6","5": 2 2 1 1
> 
> as.character(x)
[1] "5" "5" "6" "6"
> # here is where people sometimes get lost...
> as.numeric(x)
[1] 2 2 1 1
> # you probably want
> as.numeric(as.character(x))
[1] 5 5 6 6
> 
#+end_example

* Exercise solutions

** Exercise 0 prototype						  :prototype:

** Exercise 0 
Use the built-in /iris/ data set (comes with R, will be available in your workspace automatically).
1) [@1] Determine the =class= and =str= ucture of the /iris/ data set.
#+BEGIN_SRC R
  class(iris)
  str(iris)
#+END_SRC

#+RESULTS:
#+begin_example
> class(iris)
[1] "data.frame"
> str(iris)
'data.frame':	150 obs. of  5 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> 
#+end_example

2) [@2] Determine the class of each column in the iris data set
#+BEGIN_SRC R
  class(iris$Species)
  class(iris$Sepal.Length)
  class(iris$Sepal.Width)
  class(iris$Petal.Length)
  class(iris$Petal.Width)
#+END_SRC

#+RESULTS:
#+begin_example
> class(iris$Species)
[1] "factor"
> class(iris$Sepal.Length)
[1] "numeric"
> class(iris$Sepal.Width)
[1] "numeric"
> class(iris$Petal.Length)
[1] "numeric"
> class(iris$Petal.Width)
[1] "numeric"
> 
#+end_example

3) [@3] BONUS (OPTIONAL): Create a new variable by =c= ombining the Petal.Length and Petal.Width columns
#+BEGIN_SRC R
  petal <- c(iris$Petal.Length, iris$Petal.Width)
#+END_SRC

#+RESULTS:
#+begin_example
> petal <- c(iris$Petal.Length, iris$Petal.Width)
> 
#+end_example

4) [@4] BONUS (OPTIONAL): Create a new data.frame with two columns; the first should be named /value/, and should be equal to the variable you created in step 3. The second should be named /variable/ and should be either /Petal.Length/ or /Petal.Width/ as appropriate.
#+BEGIN_SRC R
  petals <- data.frame(value = petal,
                       variable = rep(c("Petal.Length", "Petal.Width"),
                                      each = nrow(iris)))

  head(petals)
  tail(petals)
#+END_SRC

#+RESULTS:
#+begin_example
> petals <- data.frame(value = petal,
+                      variable = rep(c("Petal.Length", "Petal.Width"),
+                                     each = nrow(iris)))
> 
> head(petals)
  value     variable
1   1.4 Petal.Length
2   1.4 Petal.Length
3   1.3 Petal.Length
4   1.5 Petal.Length
5   1.4 Petal.Length
6   1.7 Petal.Length
> tail(petals)
    value    variable
295   2.5 Petal.Width
296   2.3 Petal.Width
297   1.9 Petal.Width
298   2.0 Petal.Width
299   2.3 Petal.Width
300   1.8 Petal.Width
> 
#+end_example


** Exercise 1 prototype						  :prototype:

1) [@1] Select just the Sepal.Length and Species columns from the /iris/ data set (built-in, will be available in your workspace automatically) and save the result to a new data.frame named /iris.2/
#+name: ex1.1
#+begin_src R :exports code
  data(iris)
  iris2 <- iris[c("Sepal.Length", "Species")]
  str(iris2)
#+end_src

#+RESULTS: ex1.1
#+begin_example
> data(iris)
> iris2 <- iris[c("Sepal.Length", "Species")]
> str(iris2)
'data.frame':	150 obs. of  2 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> 
#+end_example

2) [@2] Calculate the mean of the Sepal.Length column in /iris.2/ 

#+name: ex.2
#+begin_src R :exports code
  mean(iris2[ , "Sepal.Length"])
#+end_src

#+RESULTS: ex.2
#+begin_example
> mean(iris2[ , "Sepal.Length"])
[1] 5.843333
> 
#+end_example

3) [@3] BONUS (optional): Calculate the mean of Sepal.Length, but only for the setosa species

#+name: ex1.3
#+begin_src R :exports code
  mean(iris2[iris2[["Species"]] == "setosa", "Sepal.Length"])
  ## shortcut:
  with(iris2, {
      print(mean(Sepal.Length[Species == "setosa"]))
  })
#+end_src

#+RESULTS: ex1.3
#+begin_example
> mean(iris2[iris2[["Species"]] == "setosa", "Sepal.Length"])
[1] 5.006
> ## shortcut:
> with(iris2, {
+     print(mean(Sepal.Length[Species == "setosa"]))
+ })
[1] 5.006
> 
#+end_example

4) [@4] BONUS (optional): Calculate the number of sepal lengths that are more than one standard deviation below the average sepal length

#+name: ex1.4
#+begin_src R :exports code
  m.minus.sd <- mean(iris2[["Sepal.Length"]]) - sd(iris2[["Sepal.Length"]])
  length(iris2[iris2[["Sepal.Length"]] < m.minus.sd, "Sepal.Length"])
#+end_src

#+RESULTS: ex1.4
#+begin_example
> m.minus.sd <- mean(iris2[["Sepal.Length"]]) - sd(iris2[["Sepal.Length"]])
> length(iris2[iris2[["Sepal.Length"]] < m.minus.sd, "Sepal.Length"])
[1] 32
> 
#+end_example
 

** Exercise 2 prototype						  :prototype:

1) [@1] Write a function that takes a data.frame as an argument and returns the mean of each numeric column in the data frame. Test your function using the iris data.

#+name: ex3.1
#+begin_src R :exports code
  statsum <- function(df) {
      classes <- sapply(df, class)
      means <- sapply(df[classes == "numeric"], mean)
      return(means)}
  
  statsum(iris) 
#+end_src

#+RESULTS: ex3.1
#+begin_example
> statsum <- function(df) {
+     classes <- sapply(df, class)
+     means <- sapply(df[classes == "numeric"], mean)
+     return(means)}
> 
> statsum(iris) 
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    5.843333     3.057333     3.758000     1.199333 
> 
#+end_example


2) [@2] Modify your function so that it returns a list, the first element if which is the means of the numeric variables, the second of which is the counts of the levels of each categorical variable.
#+name: ex3.2
#+begin_src R :exports code
  statsum <- function(df) {
      classes <- sapply(df, class)
      means <- sapply(df[classes == "numeric"], mean)
      counts <- sapply(df[classes == "factor"], table)
      return(list(means, counts))}
    
  statsum(iris) 
#+end_src

#+RESULTS: ex3.2
#+begin_example
> statsum <- function(df) {
+     classes <- sapply(df, class)
+     means <- sapply(df[classes == "numeric"], mean)
+     counts <- sapply(df[classes == "factor"], table)
+     return(list(means, counts))}
>   
> statsum(iris) 
[[1]]
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    5.843333     3.057333     3.758000     1.199333 

[[2]]
           Species
setosa          50
versicolor      50
virginica       50

> 
#+end_example

** Exercise 3 prototype						  :prototype:

1) [@1] Add argument checking code to return an error if the argument to your function is not a data.frame

#+name: ex4.1
#+begin_src R :eval no :exports code
  statsum <- function(df) {
      if(class(df) != "data.frame") stop("df must be a data.frame!")
      classes <- sapply(df, class)
      means <- sapply(df[classes == "numeric"], mean)
      counts <- sapply(df[classes == "factor"], table)
      return(list(means, counts))}
    
  statsum(1:10)
  statsum(iris)
#+end_src

2) [@2] Insert a break point with =browser()= and step through your function

#+name: ex4.2
#+begin_src R :exports code
  statsum <- function(df) {
      if(class(df) != "data.frame") stop("df must be a data.frame!")
  browser()
      classes <- sapply(df, class)
      means <- sapply(df[classes == "numeric"], mean)
      counts <- sapply(df[classes == "factor"], table)
      return(list(means, counts))
  }
  
  statsum(iris)    
#+end_src

#+RESULTS: ex4.2
#+begin_example
> statsum <- function(df) {
+     if(class(df) != "data.frame") stop("df must be a data.frame!")
+ browser()
+     classes <- sapply(df, class)
+     means <- sapply(df[classes == "numeric"], mean)
+     counts <- sapply(df[classes == "factor"], table)
+     return(list(means, counts))
+ }
> 
> statsum(iris)    
Called from: statsum(iris)
Browse[1]> [[1]]
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    5.843333     3.057333     3.758000     1.199333 

[[2]]
           Species
setosa          50
versicolor      50
virginica       50

> 
#+end_example


** Exercise 4 prototype						  :prototype:
1) [@1] Modify your function so that it also returns the standard deviations of the numeric variables 

#+name: ex5.1
#+begin_src R :exports code
  statsum <- function(df) {
      if(class(df) != "data.frame") stop("df must be a data.frame!")
      classes <- sapply(df, class)
      means <- sapply(df[classes == "numeric"], mean)
      sds <- sapply(df[classes == "numeric"], mean)
      counts <- sapply(df[classes == "factor"], table)
      return(list(cbind(means, sds), counts))}
  
  statsum(iris)
#+end_src

#+RESULTS: ex5.1
#+begin_example
> statsum <- function(df) {
+     if(class(df) != "data.frame") stop("df must be a data.frame!")
+     classes <- sapply(df, class)
+     means <- sapply(df[classes == "numeric"], mean)
+     sds <- sapply(df[classes == "numeric"], mean)
+     counts <- sapply(df[classes == "factor"], table)
+     return(list(cbind(means, sds), counts))}
> 
> statsum(iris)
[[1]]
                means      sds
Sepal.Length 5.843333 5.843333
Sepal.Width  3.057333 3.057333
Petal.Length 3.758000 3.758000
Petal.Width  1.199333 1.199333

[[2]]
           Species
setosa          50
versicolor      50
virginica       50

> 
#+end_example

2) [@2] Modify your function so that it returns a list of class "statsum"

#+name: ex5.2
#+begin_src R :exports code
  statsum <- function(df) {
      if(class(df) != "data.frame") stop("df must be a data.frame!")
      classes <- sapply(df, class)
      means <- sapply(df[classes == "numeric"], mean)
      sds <- sapply(df[classes == "numeric"], mean)
      counts <- sapply(df[classes == "factor"], table)
      R <- list(cbind(means, sds), counts)
      class(R) <- c("statsum", class(R))
      return(R)}

  str(statsum(iris))
#+end_src

#+RESULTS: ex5.2
#+begin_example
> statsum <- function(df) {
+     if(class(df) != "data.frame") stop("df must be a data.frame!")
+     classes <- sapply(df, class)
+     means <- sapply(df[classes == "numeric"], mean)
+     sds <- sapply(df[classes == "numeric"], mean)
+     counts <- sapply(df[classes == "factor"], table)
+     R <- list(cbind(means, sds), counts)
+     class(R) <- c("statsum", class(R))
+     return(R)}
> 
> str(statsum(iris))
List of 2
 $ : num [1:4, 1:2] 5.84 3.06 3.76 1.2 5.84 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:4] "Sepal.Length" "Sepal.Width" "Petal.Length" "Petal.Width"
  .. ..$ : chr [1:2] "means" "sds"
 $ : int [1:3, 1] 50 50 50
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:3] "setosa" "versicolor" "virginica"
  .. ..$ : chr "Species"
 - attr(*, "class")= chr [1:2] "statsum" "list"
> 
#+end_example


3 [@3] Write a print method for the statsum class

#+name: ex5.3
#+begin_src R :exports code
  print.statsum <- function(x) {
      cat("Numeric variable descriptive statistics:\n")
      print(x[[1]], digits=2) 
      cat("Factor variable counts:\n")
      print(x[[2]])
  }
  
  statsum(iris)
#+end_src

#+RESULTS: ex5.3
#+begin_example
> print.statsum <- function(x) {
+     cat("Numeric variable descriptive statistics:\n")
+     print(x[[1]], digits=2) 
+     cat("Factor variable counts:\n")
+     print(x[[2]])
+ }
> 
> statsum(iris)
Numeric variable descriptive statistics:
             means sds
Sepal.Length   5.8 5.8
Sepal.Width    3.1 3.1
Petal.Length   3.8 3.8
Petal.Width    1.2 1.2
Factor variable counts:
           Species
setosa          50
versicolor      50
virginica       50
> 
#+end_example


* Additional resources

** Additional reading and resources
- Learn from the best: [[http://adv-r.had.co.nz/]]
- S3 system overview: https://github.com/hadley/devtools/wiki/S3
- S4 system overview: https://github.com/hadley/devtools/wiki/S4
- R documentation: http://cran.r-project.org/manuals.html
- Collection of R tutorials: http://cran.r-project.org/other-docs.html

- R for Programmers (by Norman Matloff, UC--Davis)
http://heather.cs.ucdavis.edu/~matloff/R/RProg.pdf
- Calling C and Fortran from R (by Charles Geyer, UMinn)
http://www.stat.umn.edu/~charlie/rc/
- State of the Art in Parallel Computing with R (Schmidberger et al.)
http://www.jstatso|.org/v31/i01/paper

- Institute for Quantitative Social Science: http://iq.harvard.edu
- Research technology consulting: http://projects.iq.harvard.edu/rtc


** Feedback
- Help Us Make This Workshop Better!
- Please take a moment to fill out a very short feedback form 
- These workshops exist for you -- tell us what you need! 
- http://tinyurl.com/RprogrammingFeedback 


* OLD STUFF
** Vector types

Vectors are the building blocks of data objects in R. There are a few basic types, including =logical=, =integer= , =double=, =complex=, and =character=. Values can be combined into vectors using the ~c()~ function.
#+name: VectorsExample
#+begin_src R
  num.var <- c(1, 2, 3, 4) # numeric vector
  char.var <- c("1", "2", "3", "4") # character vector
  log.var <- c(TRUE, TRUE, FALSE, TRUE) # logical vector
  char.var2 <- c(num.var, char.var) # numbers coverted to character
#+end_src

#+RESULTS: VectorsExample
#+begin_example
> num.var <- c(1, 2, 3, 4) # numeric vector
> char.var <- c("1", "2", "3", "4") # character vector
> log.var <- c(TRUE, TRUE, FALSE, TRUE) # logical vector
> char.var2 <- c(num.var, char.var) # numbers coverted to character
> 
#+end_example

Vectors can be converted from one class to another using one of the many functions beginning with =as.=, e.g., =as.numeric= and =as.character=.
#+name: VectorClassConversion
#+begin_src R
  class(char.var2)
  num.var2 <- as.numeric(char.var2) # convert to numeric
  class(num.var2)
  mean(as.numeric(char.var2)) # now we can calculate the mean
  as.numeric(c("a", "b", "c")) # cannot convert letters to numeric
#+end_src

#+RESULTS: VectorClassConversion
#+begin_example
> class(char.var2)
[1] "character"
> num.var2 <- as.numeric(char.var2) # convert to numeric
> class(num.var2)
[1] "numeric"
> mean(as.numeric(char.var2)) # now we can calculate the mean
[1] 2.5
> as.numeric(c("a", "b", "c")) # cannot convert letters to numeric
[1] NA NA NA
> 
#+end_example

** Vector attributes
Vectors (and other R objects for that matter) will always have =mode= and =length= attributes. They may optionally have other attributes such as names or comments. 
#+begin_src R
  ls() # list objects in our workspace
  length(char.var) # how many elements in char.var?
  str(num.var2) # what is the structure of num.var2?
  names(num.var2) <- paste("element", seq_along(num.var2))
  str(num.var2)
#+end_src

#+RESULTS:
#+begin_example
> ls() # list objects in our workspace
[1] "char.var"   "char.var2"  "isPositive" "log.var"    "num.var"   
[6] "num.var2"   "petal"      "petals"     "updateIR"  
> length(char.var) # how many elements in char.var?
[1] 4
> str(num.var2) # what is the structure of num.var2?
 num [1:8] 1 2 3 4 1 2 3 4
> names(num.var2) <- paste("element", seq_along(num.var2))
> str(num.var2)
 Named num [1:8] 1 2 3 4 1 2 3 4
 - attr(*, "names")= chr [1:8] "element 1" "element 2" "element 3" "element 4" ...
> 
#+end_example

#+RESULTS: VectorLengthStructure
#+begin_example
> ls() # list objects in our workspace
[1] "char.var"  "char.var2" "log.var"   "num.var"   "num.var2" 
[6] "tmp"      
> length(char.var) # how many elements in char.var?
[1] 4
> str(num.var2) # what is the structure of num.var2?
 num [1:8] 1 2 3 4 1 2 3 4
> 
#+end_example

** Factor vectors
 Factors are stored as numbers, but have character labels. Factors are useful for
  - Modeling (automatically contrast coded)
  - Sorting/presenting values in arbitrary order

Most of the time we can treat factors as though they were character vectors

** Lists and data.frames
- A /data.frame/ is a list of vectors, each of the same length
- A /list/ is a collection of objects each of which can be almost anything

#+name: ListsAndDataframeExample
#+begin_src R
  DF <- data.frame(x=1:5, y=letters[1:5])
  DF # data.frame with two columns and 5 rows
  DF$x # select just the x column.

  # DF <- data.frame(x=1:10, y=1:7) # illegal becase lengths differ
  L <- list(x=1:5, y=1:3, z = DF)
  L # lists are much more flexible!
#+end_src

#+RESULTS: ListsAndDataframeExample
#+begin_example
> DF <- data.frame(x=1:5, y=letters[1:5])
> DF # data.frame with two columns and 5 rows
  x y
1 1 a
2 2 b
3 3 c
4 4 d
5 5 e
> 
> # DF <- data.frame(x=1:10, y=1:7) # illegal becase lengths differ
> L <- list(x=1:5, y=1:3, z = DF)
> L # lists are much more flexible!
$x
[1] 1 2 3 4 5

$y
[1] 1 2 3

$z
  x y
1 1 a
2 2 b
3 3 c
4 4 d
5 5 e

> 
#+end_example

** Data types summary
Key points:
- vector classes include numeric, logical, character, and factors
- vectors can be combined into lists or  data.frames
- a data.frame can almost always be thought of as a list of vectors of equal length
- a list is a collection of objects, each of which can by of almost any type
Functions introduced in this section: 
- c :: combine elements
- as.numeric :: convert an object (e.g., a character verctor) to numeric
- data.frame :: combine oject into a data.frame
- ls :: list the objects in the workspace
- class :: get the class of an object
- str :: get the structure of an object
- length :: get the number of elements in an object
- mean :: calculate the mean of a vector
- $ :: extraction operator, selects a single element from a list or data.frame 

** Exercise 0 
Use the built-in /iris/ data set (comes with R, will be available in your workspace automatically).
1. Determine the =class= and =str= ucture of the /iris/ data set.
2. Determine the class of each column in the iris data set
3. BONUS (OPTIONAL): Create a new variable by =c= ombining the Petal.Length and Petal.Width columns
4. BONUS (OPTIONAL): Create a new data.frame with two columns; the first should be named /value/, and should be equal to the variable you created in step 3. The second should be named /variable/ and should be either /Petal.Length/ or /Petal.Width/ as appropriate.

* Footnotes

[fn:2] [[http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags]]

[fn:1] Center for Economic and Policy Research. 2015. CPS ORG Uniform Extracts, Version 2.0.1. Washington, DC.
